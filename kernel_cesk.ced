;
;
;******************************************************************************
;
;	Arquivo de Referência para o desenvolvimento do kernel.
;
;	Versão: 2021.1
;
;	Áreas de memória
;
;	0000 - 7FFF		_KERNEL
;					Área de Kernel para implementação dos alunos
;
;	0100 - 01FF		_VETTAB
;					Tabela com os vetores das funções do kernel
;					*** CUIDADO! Esse vetor está no meio da área de código ***
;
;	8000 - FF7F		_APP
;					Área onde será colocado o programa de aplicação.
;					Esse programa vai fazer o acesso aos periféricos e interrupções, através das funções do Kernel.
;
;	FF80 - FFBF 	_IOAREA16
;					Area de perifericos, acessada na base 16 bits
;
;	FFC0 - FFFF		_IOAREA08
;					Area de perifericos, acessada na base 8 bits
;					
;******************************************************************************


_KERNEL:	equ	h0000
_VETTAB:	equ	h0100
_APP:		equ	h8000
_IOAREA16:	equ	hFF80
_IOAREA08:	equ	hFFC0


;
;------------------------------------------------------------------------------
;	Área reservada para os periféricos
;------------------------------------------------------------------------------

; Acesso em 16 bits
		org		_IOAREA16
STACK:		daw		[31]
IVET:	dw		0			; Vetor de interrupção

; Acesso em 8 bits
		org		_IOAREA08
		dab		[15]
; Clock Variables
CLKST:		dab		[2]			; CLOCK STATUS: 	x x x x . x x SA SV ( SA {bit 1} -> Status de ativação , SV {bit0} -> Status de Visibilidade )
CLKTM_DS:	dab		[2]			; CLOCK DÉCIMOS DE SEGUNDOS -> char CLKTM_DS[2] = { 0 };
CLKTM:		dab		[4]			; CLOCK TIME:   { x x m0 m0.m0 m0 m0 m0   ,   x x s0 s0.s0 s0 s0 s0   ,   x x m1 m1.m1 m1 m1 m1  ,   x x s1 s1.s1 s1 s1 s1 }  -> char CLKTM[2][2] = { 0 };


;	System
TIMDT:	db		0			; Registro de programação do timer
INTS:	db		0			; INTERRUPT STATUS: IP x x x . x x IPStec IPStim
INTE:	db		0			; INTERRUPT ENABLE: IE x x x . x x IEStec IEStim :: &INTE = 65497 = hFFD9 
TECST:	db		0			; Status do teclado
TECDT:	db		0			; Dado do teclado
VISOR:	dab		[36]		; Portas de acesso ao visor

;	
;------------------------------------------------------------------------------
;	Ponto de entrada do RESET do processador
;------------------------------------------------------------------------------
		org		_KERNEL
		jmp		_RESET

;
;------------------------------------------------------------------------------
;	Area do kernel com os vetores das funções do kernel
;------------------------------------------------------------------------------
		org		_VETTAB
		dw		_kbhit			;ok
		dw		_getchar		;ok ( falta cursor piscar com underline ( ou underscore ): '_' 
		dw		_putchar		;ok
		dw		_get_clock_status	;ok
		dw		_get_clock_time		;ok2
		dw		_turnon_clock		;ok2
		dw		_clr_clock		;ok2
		
;	
;------------------------------------------------------------------------------
;	Código de RESET (BOOT) do processador/interrupção
;------------------------------------------------------------------------------
		org		_VETTAB+h0100
_RESET:		
; 1) Desabilitar o sistema de interrupções
; 2) Inicializar o stack pointer (SP = R6)
; 3) Inicializar as variáveis internas usadas pelo sistema de interrupções e periféricos (IVET, INTE, etc.)
; 4) Inicializar as variáveis internas do kernel
; 5) Inicializar o teclado zerando o byte de estado (TECST, endereço 65498)
; 6) Inicializar o timer
; 7) Limpar o visor
; 8) Habilitar interrupções
; 9) Retornar para o programa de aplicação com um desvio para o endereço _APP da memória
	
	mov 	#0, INTE			; Desabilitar Interrupções 
		
	mov 	#_APP-2, R6  			; Define StackBase
	
	
	clr 	INTS				; Reinicia os pedidos por interrupção
	
	mov 	#Isr, IVET			; Define vetor de interrupções		
	
	;mov 	#3 , INTE			; Liga bits de destravamento das interrupções do teclado e do timmer
	
	clr 	TECST				; Inicializar Teclado

	mov 	#100, TIMDT			; Inicializar Timer
	
	;jsr 	R7 , limpa_visor		; Limpar Visor
	mov	#0 , POS_CURSOR			; Posiciona o cursor no primeiro bloco do display
	
	
	mov	#0, R5
	jsr	R7, _clr_clock
	mov 	#1, R5
	jsr	R7, _clr_clock			; Inicializa variáveis do relógio
	mov	#3, CLKST
	
	;or	#h80, INTE			; Habilita Interrupções	
	mov	#h83, INTE
	
	jmp	_APP

;		
;------------------------------------------------------------------------------
; Função através da qual pode-se solicitar ao kernel a informação sobre a existência de tecla digitada.
; A função deve retornar com a informação da existência de tecla, sem aguardar pela digitação de qualquer tecla. 
; - Parâmetros de entrada: nenhum. 
; - Parâmetro de saída: registrador R0, com a informação da existência de tecla. 
; A função retorna no registrador R0 a informação se existe tecla ou não. 
; - Se há tecla, o valor em R0 será zero; 
; - Se não há tecla, o valor em R0 será um valor qualquer diferente de zero. 
;------------------------------------------------------------------------------
_kbhit:
		tst 	TECST
		beq 	continua_kbhit_0
		
		mov #1, R0	; Não há tecla sendo pressionada
		jmp FIM_KBHIT	; return 1

		continua_kbhit_0:		; Há tecla sendo pressionada
				mov #0,  R0	; return 0
		
		FIM_KBHIT:
				rts		r7
		
;		
;------------------------------------------------------------------------------
; Função através da qual pode-se solicitar ao kernel que aguarde pela digitação de uma tecla.
; A função deve retornar o código ASCII da tecla digitada.
; Portanto, a função deve aguardar pela digitação de uma tecla. 
; - Parâmetros de entrada: nenhum. 
; - Parâmetro de saída: registrador R0, com a tecla digitada. 
; A função só retorna (só termina) quando o usuário digitar alguma tecla.
; O código ASCII da tecla digitada deve ser retornado no registrador R0. 
; Sempre que a função “_getchar” for chamada e estiver bloqueada aguardando por uma tecla,
;     a posição do cursor deve ser apresentado no visor através do símbolo “_” (underscore).
; Esse símbolo deve ser alternado com o caractere que estiver sendo apresentado nessa posição.
; Essa alternância deve ter uma periodicidade tal que cada símbolo permaneça no visor por 500ms. 
;------------------------------------------------------------------------------
_getchar:
		tst		TECST
		beq		_getchar		; while( !houve_tecla_digitada ){/* POR ENQUANTO, nada a fazer( CURSOR DEVERÁ PISCAR ) */}
		
		mov 		TECDT, R0
		clr 		TECST
		rts		r7
		
;		
;------------------------------------------------------------------------------
; Envia um caractere ASCII para o visor.
; Esse caractere pode ser um caractere visível ou um caractere de controle. 
; - Parâmetros de entrada: registrador R5, com o caractere a ser colocado no visor. 
; - Parâmetro de saída: registrador R0, com o código de erro de retorno. 
; O código no registrador R5 pode representar caracteres visíveis ou caracteres de controle. 
; Na inicialização do kernel, o visor deve ser limpo (apagado) e o cursor deve ser posicionado no início do visor. 
; A função retorna no registrador R0 um código de erro. 
; - Se não houve erro, o valor em R0 será zero; 
; - Se houve algum erro ou informação inválida de entrada, o valor em R0 será um valor qualquer diferente de zero. 
;------------------------------------------------------------------------------
_putchar:	
		cmp 	R5, CR
		beq	PUTCHAR_CR 		; if( in == '\n' ) goto PUTCHAR_CR

		cmp 	R5, BS
		beq	PUTCHAR_BS 		; ; if( in == '\n' ) goto PUTCHAR_BS	
		
		cmp	POS_CURSOR , #21
		bgt	PUTCHAR_ERROR_CD	; Cursor FORA dos Limites do Visor para Texto
		cmp	POS_CURSOR, #0	
		blt	PUTCHAR_ERROR_CD
		
		mov	#VISOR, R0	
		mov	R5, POS_CURSOR(R0)	; Escreve na tela
		
	
		mov 	#0 , R0					
		cmp 	POS_CURSOR, #21
		beq 	FIM_PUTCHAR					;return 0
		
		INC_CURSOR:
				inc 	POS_CURSOR		; POS_CURSOR++
				jmp 	FIM_PUTCHAR			; return 0
		
		PUTCHAR_ERROR_EI:
				mov 	#1 , R0
				jmp FIM_PUTCHAR			; return 1
				
		PUTCHAR_ERROR_CD:
				mov 	#2 , R0
				jmp FIM_PUTCHAR			; return 2

		PUTCHAR_CR:
				mov #0, R0
				clr POS_CURSOR

				jmp FIM_PUTCHAR				; return 0
		PUTCHAR_BS:
				mov #0, R0
				
				tst POS_CURSOR
				beq FIM_PUTCHAR			; return 0

				dec POS_CURSOR			; POS_CURSOR --
				
				mov #VISOR, R0			; 
				clr POS_CURSOR(R0)		; VISOR[ POS_CURSOR ] = 0

				jmp FIM_PUTCHAR				; return 0
		
		FIM_PUTCHAR:
				rts	r7
		
		
;		
;------------------------------------------------------------------------------
; Essa função fornece as informações relativas à situação atual de cada relógio, 
; no que diz respeito à sua visibilidade e se está andando. 
; - Parâmetros de entrada: registrador R5, com o identificador do relógio a ser lido.
;   Esse valor pode ser 0 (zero) ou 1 (um). 
; Outros valores devem ser ignorados. 
; - Parâmetro de saída: registrador R0, com a indicação do estado do relógio (visibilidade e se está parado). 
; No retorno da função, o registrador R0 conterá as informações do estado do relógio em seus bits 0 e bit 1. 
; O bit 0, quando ligado (valor “1”), indica que o relógio está visível;
; O bit 1, quando ligado (valor “1”), indica que o relógio está andando. 
;------------------------------------------------------------------------------
_get_clock_status:
	; Checa se relógio existe
		cmp R5, 0
		blt RELOGIO_INEXISTENTE		
		cmp R5, 1 
		bgt RELOGIO_INEXISTENTE		
	
	; Retorno normal ( em caso de relógio existente: R5 == 0 v R5 == 1 )	
		mov 	CLKST(R5), R0
		rts 	r7			; return CLKST[ R5 ]
	
	; Retorno anômalo ( em caso de relógio inexistente: R5 != 0 ^ R5 != 1 )	
		RELOGIO_INEXISTENTE:		
				mov #0, R0
				rts		r7
	
;		
;------------------------------------------------------------------------------
; Essa função fornece o valor atual de cada relógio.
; Essa informação é fornecida como um número inteiro de segundos.
; Como cada relógio tem minutos e segundos,
;     o valor fornecido deverá ser o resultado da aplicação da seguinte fórula (60*MIN+SEG). 
; - Parâmetros de entrada: registrador R5, com o identificador do relógio a ser lido.
;   Esse valor pode ser 0 (zero) ou 1 (um). Outros valores devem ser ignorados. 
; - Parâmetro de saída: registrador R0, com o número de segundos atualmente presentes no relógio. 
; No retorno da função, o registrador R0 conterá o número de segundos correspondentes à informação atual no relógio.
; Essa informação corresponde àquela presente no relógio, independentemente de seu estado (visível/invisível ou parado/andando). 
;------------------------------------------------------------------------------
_get_clock_time:
		; Verifica se relógio existe
		cmp 	R5, 0
		blt 	FIM_GETTIME_A
		cmp 	R5, 1
		bgt	FIM_GETTIME_A

		; Salva Registradores
		mov 	R1, -(R6)		; Salva valor de R1
		mov 	R5, -(R6)   		; Salva valor de R5
		
		; Minutos
		asl	R5				;|
		inc	R5				;|
		mov 	CLKTM(R5), R1			;|> R1 = CLKTM[ CÓD_CLK ][1]     <=>   R1 = *(CLKTM + CÓD_CLK*2 + 1 )

		jsr 	R7, mintoseg			; R0 = mintoseg( R1 )		 <=>   R0 = 60 * CLKTM[ CÓD_CLK ][1]
		
		; Segundos
		dec	R5				;|
		add 	CLKTM(R5), R0			;| R0 += CLKTM[ CÓD_CLK ][0] 	

		

		FIM_GETTIME_A:
				clr	R0
				rts	R7
		FIM_GETTIME:		
				mov 	(R6), R5		; Restaura registrador R5
				mov 	(R6), R1		; Restaura registrador R1
				rts	r7
		
;		
;------------------------------------------------------------------------------
; Essa função é usada para indicar ao kernel se o relógio deve “andar” ou “parar”.  
; - Parâmetros de entrada: 
;   - registrador R5, com o identificador do relógio a ser ativado/desativado.
;     Esse valor pode ser 0 (zero) ou 1 (um). Outros valores devem ser ignorados; 
;   - registrador R4, com a indicação do estado a ser colocado o relógio.
;     Esse valor pode ser 0 (zero), caso o relógio deva parar,
;     ou um valor diferente de 0 (zero), caso o relógio deva andar. 
; - Parâmetro de saída: registrador R0, com o código de erro de retorno. 
; A função retorna no registrador R0 um código de erro. 
; - Se não houve erro, o valor em R0 será zero; 
; - Se houve algum erro ou informação inválida de entrada,
;   o valor em R0 será um valor qualquer diferente de zero. 
;------------------------------------------------------------------------------
_turnon_clock:
		; Testar Parâmetros de entrada
		
			
		; Seleção de Ação
		tst 	R4
		beq 	PAUSAR_CLK
		jmp 	REATIVAR_CLK

		
		PAUSAR_CLK:
				and 	#hFFFD, CLKST		; Aplica máscara para desligar bit 1 { SA }
				jmp	END_TURNONCLK
		REATIVAR_CLK:
				or 	#2, CLKST		; Aplica máscara para ligar bit 1 { SA }
		
		END_TURNONCLK:
				mov 	#0, R0
				rts	r7
		
;		
;------------------------------------------------------------------------------
; Essa função é usada para indicar ao kernel que o relógio deve ser zerado.
; Ou seja, minutos e horas armazenado no relógio devem ser zerados. 
; - Parâmetros de entrada: registrador R5, com o identificador do relógio a ser zerado.
;   Esse valor pode ser 0 (zero) ou  1 (um). Outros valores devem ser ignorados; 
; - Parâmetro de saída: registrador R0, com o código de erro de retorno. 
; A função retorna no registrador R0 um código de erro. 
; - Se não houve erro, o valor em R0 será zero; 
; - Se houve algum erro ou informação inválida de entrada,
;          o valor em R0 será um valor qualquer diferente de zero. 
;------------------------------------------------------------------------------
_clr_clock:
		; Zerar Décimos de Segundos
		clr	CLKTM_DS(R5)	
		
		; Zerar Minutos
		asl	R5			; R5 *= 2
		clr 	CLKTM(R5)		; Zera Minutos   <=>   CLKTM[ R5 ][ 0 ] = 0   <=>  *(CLKTM + 2*R5 + 0 )   <=>   *(CLKTM + QTD_LINHAS*CLK_ATUAL + CAMPO_ATUAL )
		
		; Zerar Segundos
		inc 	R5
		clr 	CLKTM(R5)		; Zera Segundos  <=>   CLKTM[ R5 ][ 1 ] = 0   <=>  *(CLKTM + 2*R5 + 1 ) 
		
		
		END_CLR_CLK:
				mov 	#0, R0
				rts	r7


;		
;------------------------------------------------------------------------------
; Tratador de interrupções( Interrupt Service Routine )
; Função invocada a cada interrupção de hardware. Analisa qual ou quais periféricos
; provocou ou provocaram a interrupções e define ação a ser tomada.
; - Parâmetros de entrada: variável INTS, cujo bit zero informa se timer provocou interrupção,
; e o bit um informa se o teclado invocou a interrupção. O o bit ativo signifa que aquele periférico,
; solicitou uma interrupção. Obs.: Pode acontecer de mútiplos periféricos solicitarem a interrupção,
;  no mesmo ciclo.
;   Esse valor pode ser 81h (Timer) ou  82h (Teclado) ou 83h(Timer e Teclado).
 
;------------------------------------------------------------------------------
Isr:		
		
		mov		r0,-(r6)	; Salva registradores
		mov		r1,-(r6)
		mov		r2,-(r6)
		mov		r3,-(r6)
		mov		r4,-(r6)
		mov		r5,-(r6)
		
		mov		INTS,r0		; Verifica se é INT do TECLADO
		and		#2,r0
		beq		ISR2
		jsr		R7,ISRtec	; Tratamento da INT do TECLADO
		and		#hFFFD,INTS	; Desliga bit de INT TECLADO		

		ISR2:		
				mov		INTS,r0		; Verifica se é INT do TIMER
				and		#1,r0
				beq		ISR3
				mov		INTE,r0		; Verifica se é INT do TIMER
				and		#1,r0
				beq		ISR3
				jsr		r7,ISRtim	; Tratamento da INT do TIMER
				and		#hFFFE,INTS	; Desliga bit de INT TIMER

		ISR3:
				mov		(r6)+,r5	; Retorna os registradores da pilha
				mov		(r6)+,r4
				mov		(r6)+,r3
				mov		(r6)+,r2
				mov		(r6)+,r1
				mov		(r6)+,r0
		
		FIM_ISR:
			rti					; Return From Interrupt


; Tratamento das interrupções de teclado
ISRtec:	
		tst		TECST		
		beq		ISRtec_FIM
		
		cmp 		TECDT, #','
		beq		TROCAR_VIS_0
		cmp 		TECDT, #'.'
		beq		TROCAR_VIS_1
						
		rts		R7
		ISRtec_FIM:
			clr 	TECST
			clr 	TECDT					
			rts	r7						

		TROCAR_VIS_0:	
				mov 	#0, R0
				mov	CLKST(R0), R0
				and	#1, R0
		
				tst	R0
				beq	AC_TROCAR_VIS_0
		
				mov 	#0, R0
				and 	#hFE, CLKST(R0)
		
				jmp	ISRtec_FIM

				AC_TROCAR_VIS_0:
					mov 	#0, R0
					or 	#1, CLKST(R0)
			
					jmp	ISRtec_FIM
		
	
		TROCAR_VIS_1:
				mov 	#1, R0
				mov	CLKST(R0), R0
				and	#1, R0
		
				tst	R0
				beq	AC_TROCAR_VIS_1
		
				mov 	#1, R0
				and 	#hFE, CLKST(R0)
		
				jmp	ISRtec_FIM

				AC_TROCAR_VIS_1:
					mov 	#1, R0
					or 	#1, CLKST(R0)
				
					jmp	ISRtec_FIM


ISRtim:
		clr	 clk_atual			; Relógio(clk) atual = 0
		clr	 flag_redesenho			; flag_redesenho = false


		ATUALIZA_TEMPO_CLKS:													; do{
			;mov 		#0, R5
			;jsr		R7, _get_clock_status
			;and 		#2 , R5
			
			;beq 		RELOGIO_1_2
			
			; Seleção do Relógio
			mov 		clk_atual, R5			
			asl		R5				; R5 = 2 * Código do Relógio Escolhido( o->clk0 ou 1-> clk1)
			
			; Décimos de Segundos
			inc		CLKTM_DS(R5)			;| 
			cmp 		CLKTM_DS(R5) , #10		;|
			bne		SET_PROX_RELOGIO		;|
			clr 		CLKTM_DS(R5)			;|> Atualiza valor dos décimos de segundos do clk	
			mov		TRUE, flag_redesenho
			
			; Segundos			
			inc		R5				; R5 ++; Define Campo Atual como Segundos
			
			inc		CLKTM(R5)			;|
			cmp 		CLKTM(R5), #60			;|
			bne 		SET_PROX_RELOGIO		;|
			clr 		CLKTM(R5)			;|> Atualiza valor dos segundos do clk 
			 
			; Minutos
			dec		R5				; R5 --; Define Campo Atual como Minutos

			inc		CLKTM(R5)			;|	
			cmp 		CLKTM(R5), #60			;|
			bne 		SET_PROX_RELOGIO		;|
			clr 		CLKTM(R5)			;|> Atualiza valor dos minutos do clk
					

			SET_PROX_RELOGIO:
					inc 		clk_atual		; clk_atual++
					cmp		clk_atual, #2
					bge		FIM_ISRtim									; }while( !( clk_atual >= 2 ) );    <= >    }while( !( clk_atual < 2 ) )
					jmp		ATUALIZA_TEMPO_CLkS
			
		; Se necessário redesenha os relógios		
		REDESENHA_CLK:
			tst		flag_redesenho		;| if( flag_redesenho )
			beq		FIM_ISRtim		;|	redesenha_clks()
			jsr		R7, redesenha_clks	;|	
		
		FIM_ISRtim:
			rts 		R7
		
		; Variáveis Locais Da ISRtim
		flag_redesenho:	dw		; Indica se é necessário redesenhar os relógios( Alterações exclusivas nos décimos de segundos não requerem redesenho )
		clk_atual:	dw		; Indicador do relógio selecionado ( o valor é o código do teclado, 0 ou 1 )

;		
;------------------------------------------------------------------------------
; Limpa todos os blocos do visor
; - Parâmetros de entrada: nenhum
; - Parâmetro de saída: nenhum 
;------------------------------------------------------------------------------
limpa_visor:
		mov 	R0 , -(R6)	; Salva R0
		
		
		mov 	#VISOR , R0
		
		continua_lv:
			clr	(R0)
			cmp	R0 , hFFFF
			beq	ret_lv
			
			inc	R0
			jmp	continua_lv

		ret_lv:
			mov	(R6)+ , R0	; Restaura valor original de R0                
			rts	r7

		
;------------------------------------------------------------------------------
; Mutiplica dois números de 16 bits
; - Parâmetros de entrada: 
;				R1 -> Multiplicando
;				R2 -> Multiplicador
; - Parâmetro de saída: 
;				R0 -> Produto
;------------------------------------------------------------------------------
multiplica:
                
			rts		r7

;		
;-----------------------------------------------------------------------------
; Converte valor de tempo em minutos para segundos
; - Parâmetros de entrada: 
;				R1 -> Tempo em Minutos
; - Parâmetro de saída: 
;				R0 -> Tempo em Segundos
;------------------------------------------------------------------------------
mintoseg:
        		clr R0
			
			SOMA_60:
				add 	#60, R0
				sob	 R1, SOMA_60
						        
			rts		r7

;		
;-----------------------------------------------------------------------------
; Redesenha relógios
; - Parâmetros de entrada: nenhum
;				
; - Parâmetro de saída:  nenhum
;	
;------------------------------------------------------------------------------
redesenha_clks:
        	clr	clk_atual_2	; Clock_Atual = 0

		DESENHA_CLKS:	
				mov	clk_atual_2, R0
				mov	CLKST(R0), R0
				and	#1, R0
				beq	LMP_RL0
				
				; Desenhar sinal de  Dois pontos
				mov 	#26, R3 
				mov	#':', VISOR(R3)	; Desenha Dois pontos   <=>  VISOR[26] = ':';
				
				; Tempo - Primeiro Segundos, depois Minutos
				mov	#0, R0
				mov 	CLKTM_S(R0), R1
				jsr	R7, divd_int_10
				mov 	#27, R3
				add	#48, R2 
				mov	R2, VISOR(R3)	; Dezenas dos segundos
				
				sub	#48, R2
				jsr	R7, multp_int_10
				sub	R2, R1
				
				mov 	#28, R3
				add	#48, R1 
				mov	R1, VISOR(R3)	; Unidades dos segundos   
				 	
				RELOGIO1_PRT:
				mov	#1, R0
				mov	CLKST(R0), R0
				and	#1, R0
				beq	LMP_RL1
				
				mov 	#33, R3 
				mov	#':', VISOR(R3)	; Dois pontos   

				;mov	#0, R5
				;jsr	R7, _get_clock_time
				;mov 	R0, R1
				;jsr	R7, divd_int_10
				mov 	#34, R3

				;;mov	R2, VISOR(R3)	; Dezenas dos segundos
				mov 	#'S', VISOR(R3)

				;jsr	R7, multp_int_10
				;sub	R1, R2
				
				mov 	#35, R3 
				;;mov	R2, VISOR(R3)	; Unidades dos segundos   
				mov 	#'s', VISOR(R3)
	
			FIM_redesenha_clks:
				rts	r7
	
			
			LMP_RL0:
				mov 	#22,R0
				
				DESENHA_ESP_0:	
					mov 	#' ',VISOR(R0) 
					inc	R0
					cmp 	R0, #29
					bne	DESENHA_ESP_0
				jmp RELOGIO1_PRT			
			
			LMP_RL1:
				mov 	#29,R0
				
				DESENHA_ESP_1:	
					mov 	#' ',VISOR(R0) 
					inc	R0
					cmp 	R0, #36
					bne	DESENHA_ESP_1
				jmp FIM_redesenha_clks
		
		; Variáveis Locais
		clk_atual_2:	dw		; Indicador do clock atual
;		
;-----------------------------------------------------------------------------
; Divisão inteira por 10
; - Parâmetros de entrada: 
;				R1 -> Valor a ser dividido
;				
; - Parâmetro de saída:  
;				R2 -> Divisão
;	
;------------------------------------------------------------------------------
divd_int_10:
		clr 	cont
		mov 	R1, save_divd_10

		LOOP_DIVD_10:
			sub	#10, R1
			tst 	R1
			bmi	FIM_DIVD_10

			inc 	cont		

			tst 	R1
			beq	FIM_DIVD_10

			jmp LOOP_DIVD_10
		
		FIM_DIVD_10:
			mov 	save_divd_10, R1
			mov 	cont, R2
			rts	R7
		
		cont:		dw	
		save_divd_10:	dw

;		
;-----------------------------------------------------------------------------
; Multiplicação inteira por 10
; - Parâmetros de entrada: 
;				R2 -> Valor a ser multiplicado por 10
;				
; - Parâmetro de saída:  
;				R2 -> Produto
;	
;------------------------------------------------------------------------------
multp_int_10:
		clr 	prod

		LOOP_MULT_10:
			tst	R2
			beq	FIM_MULT_10
			add	#10, prod
			dec 	R2		
			jmp 	LOOP_MULT_10
		
		FIM_MULT_10:
			mov 	prod, R2
			rts	R7
		
		prod:		dw
	
;-----------------------------------------------------------------------------
; ########## VARIÁVEIS DO KERNEL  ##############  ( Localizadas após funções)
;-----------------------------------------------------------------------------
POS_CURSOR: 	dw 		#0			; Posição do cursor
CR: 		dw		#h0D			; Carriage Return Char
BS: 		dw		#h08			; BackSpace Char 
FALSE:		dw		#0			
TRUE:		dw		#1			

org _APP
	nop
	nop
	nop
	;inc	R4
	;jsr	R7, _kbhit
	mov	#1, R4
	mov	#0, R5
	jsr	R7, _turnon_clock


	
	mov 	#0, R3
	sub	#1, R3
	mov 	#77, R4
	LOOP:
		inc	R3
		cmp	R3, #3
		beq	LOOP_2

		mov 	R4,VISOR(R3)
		inc	R4
				
		jmp 	LOOP
	
	LOOP_2:
		mov	#40, R1
		jsr	R7, divd_int_10
		mov	R2, 37150
		jmp 	LOOP_2
	FIM_APP:
		hlt