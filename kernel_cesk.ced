;
;
;******************************************************************************
;
;	Arquivo de Referência para o desenvolvimento do kernel.
;
;	Versão: 2021.1
;
;	Áreas de memória
;
;	0000 - 7FFF		_KERNEL
;					Área de Kernel para implementação dos alunos
;
;	0100 - 01FF		_VETTAB
;					Tabela com os vetores das funções do kernel
;					*** CUIDADO! Esse vetor está no meio da área de código ***
;
;	8000 - FF7F		_APP
;					Área onde será colocado o programa de aplicação.
;					Esse programa vai fazer o acesso aos periféricos e interrupções, através das funções do Kernel.
;
;	FF80 - FFBF 	_IOAREA16
;					Area de perifericos, acessada na base 16 bits
;
;	FFC0 - FFFF		_IOAREA08
;					Area de perifericos, acessada na base 8 bits
;					
;******************************************************************************


_KERNEL:	equ	h0000
_VETTAB:	equ	h0100
_APP:		equ	h8000
_IOAREA16:	equ	hFF80
_IOAREA08:	equ	hFFC0


;
;------------------------------------------------------------------------------
;	Área reservada para os periféricos
;------------------------------------------------------------------------------

; Acesso em 16 bits
		org		_IOAREA16
STACK:		daw		[31]
IVET:	dw		0			; Vetor de interrupção

; Acesso em 8 bits
		org		_IOAREA08
		dab		[14]

; Keyboar Variables
backup_char:	db	

; Clock Variables
CLKST:		dab		[2]			; CLOCK STATUS: 	x x x x . x x SA SV ( SA {bit 1} -> Status de ativação , SV {bit0} -> Status de Visibilidade )
CLKTM_DS:	dab		[2]			; CLOCK DÉCIMOS DE SEGUNDOS -> char CLKTM_DS[2] = { 0 };
CLKTM:		dab		[4]			; CLOCK TIME:   { x x m0 m0.m0 m0 m0 m0   ,   x x s0 s0.s0 s0 s0 s0   ,   x x m1 m1.m1 m1 m1 m1  ,   x x s1 s1.s1 s1 s1 s1 }  -> char CLKTM[2][2] = { 0 };


;	System
TIMDT:	db		0			; Registro de programação do timer
INTS:	db		0			; INTERRUPT STATUS: IP x x x . x x IPStec IPStim
INTE:	db		0			; INTERRUPT ENABLE: IE x x x . x x IEStec IEStim :: &INTE = 65497 = hFFD9 
TECST:	db		0			; Status do teclado
TECDT:	db		0			; Dado do teclado
VISOR:	dab		[36]		; Portas de acesso ao visor

;	
;------------------------------------------------------------------------------
;	Ponto de entrada do RESET do processador
;------------------------------------------------------------------------------
		org		_KERNEL
		jmp		_RESET

;
;------------------------------------------------------------------------------
;	Area do kernel com os vetores das funções do kernel
;------------------------------------------------------------------------------
		org		_VETTAB
		dw		_kbhit			;ok
		dw		_getchar		;ok ( falta cursor piscar com underline ( ou underscore ): '_' 
		dw		_putchar		;ok
		dw		_get_clock_status	;ok
		dw		_get_clock_time		;ok (erro)
		dw		_turnon_clock		;ok
		dw		_clr_clock		;ok
		
;	
;------------------------------------------------------------------------------
;	Código de RESET (BOOT) do processador/interrupção
;------------------------------------------------------------------------------
		org		_VETTAB+h0100
_RESET:		
; 1) Desabilitar o sistema de interrupções
; 2) Inicializar o stack pointer (SP = R6)
; 3) Inicializar as variáveis internas usadas pelo sistema de interrupções e periféricos (IVET, INTE, etc.)
; 4) Inicializar as variáveis internas do kernel
; 5) Inicializar o teclado zerando o byte de estado (TECST, endereço 65498)
; 6) Inicializar o timer
; 7) Limpar o visor
; 8) Habilitar interrupções
; 9) Retornar para o programa de aplicação com um desvio para o endereço _APP da memória
	
	mov 	#0, INTE			; Desabilitar Interrupções 
		
	mov 	#_APP-2, R6  			; Define StackBase
	
	
	clr 	INTS				; Reinicia os pedidos por interrupção
	
	mov 	#Isr, IVET			; Define vetor de interrupções		
	
	clr 	TECST				;|
	clr 	TECDT				;|
	clr	BUFFER				;|> Inicializa Teclado

	mov 	#100, TIMDT			; Inicializar Timer
		
	
	jsr 	R7 , limpa_visor		; Limpar Visor
	mov	#0 , POS_CURSOR			; Posiciona o cursor no primeiro bloco do display
	
	
	mov	#0, R5				;|
	clr	CLKST(R5)			;|
	jsr	R7, _clr_clock			;|
	mov 	#1, R5				;|
	clr	CLKST(R5)			;|
	jsr	R7, _clr_clock			;|> Inicializa variáveis do relógio
	
			
	mov	#h83, INTE			; Habilita Interrupções	
	
	jmp	_APP

;		
;------------------------------------------------------------------------------
; Função através da qual pode-se solicitar ao kernel a informação sobre a existência de tecla digitada.
; A função deve retornar com a informação da existência de tecla, sem aguardar pela digitação de qualquer tecla. 
; - Parâmetros de entrada: nenhum. 
; - Parâmetro de saída: registrador R0, com a informação da existência de tecla. 
; A função retorna no registrador R0 a informação se existe tecla ou não. 
; - Se há tecla, o valor em R0 será zero; 
; - Se não há tecla, o valor em R0 será um valor qualquer diferente de zero. 
;------------------------------------------------------------------------------
_kbhit:
		tst 	BUFFER
		beq 	continua_kbhit_0
		
		mov #1, R0	; Não há tecla sendo pressionada
		jmp FIM_KBHIT	; return 1

		continua_kbhit_0:		; Há tecla sendo pressionada
				mov #0,  R0	; return 0
		
		FIM_KBHIT:
				rts		r7
		
;		
;------------------------------------------------------------------------------
; Função através da qual pode-se solicitar ao kernel que aguarde pela digitação de uma tecla.
; A função deve retornar o código ASCII da tecla digitada.
; Portanto, a função deve aguardar pela digitação de uma tecla. 
; - Parâmetros de entrada: nenhum. 
; - Parâmetro de saída: registrador R0, com a tecla digitada. 
; A função só retorna (só termina) quando o usuário digitar alguma tecla.
; O código ASCII da tecla digitada deve ser retornado no registrador R0. 
; Sempre que a função “_getchar” for chamada e estiver bloqueada aguardando por uma tecla,
;     a posição do cursor deve ser apresentado no visor através do símbolo “_” (underscore).
; Esse símbolo deve ser alternado com o caractere que estiver sendo apresentado nessa posição.
; Essa alternância deve ter uma periodicidade tal que cada símbolo permaneça no visor por 500ms. 
;------------------------------------------------------------------------------
_getchar:
		mov	POS_CURSOR, R0
		mov	VISOR(R0), backup_char

		LOOP_GETCHAR:
		tst	BUFFER
		bne	FIM_GETCHAR
		
		cmp	flag_piscar_cursor, #5
		bge	PUT_ORIG
		mov	#'_', VISOR(R0)
		jmp	LOOP_GETCHAR		; while( !houve_tecla_digitada ){ CURSOR FICA PISCANDO }
		
		PUT_ORIG:
			mov	backup_char, VISOR(R0)
			jmp	LOOP_GETCHAR		; while( !houve_tecla_digitada ){ CURSOR FICA PISCANDO }
		
		FIM_GETCHAR:
			mov	backup_char, VISOR(R0)
			mov 	BUFFER, R0
			clr	BUFFER	
			rts	R7
		
;		
;------------------------------------------------------------------------------
; Envia um caractere ASCII para o visor.
; Esse caractere pode ser um caractere visível ou um caractere de controle. 
; - Parâmetros de entrada: registrador R5, com o caractere a ser colocado no visor. 
; - Parâmetro de saída: registrador R0, com o código de erro de retorno. 
; O código no registrador R5 pode representar caracteres visíveis ou caracteres de controle. 
; Na inicialização do kernel, o visor deve ser limpo (apagado) e o cursor deve ser posicionado no início do visor. 
; A função retorna no registrador R0 um código de erro. 
; - Se não houve erro, o valor em R0 será zero; 
; - Se houve algum erro ou informação inválida de entrada, o valor em R0 será um valor qualquer diferente de zero. 
;------------------------------------------------------------------------------
_putchar:	
		cmp 	R5, CR
		beq	PUTCHAR_CR 		; if( in == '\n' ) goto PUTCHAR_CR

		cmp 	R5, BS
		beq	PUTCHAR_BS 		; ; if( in == '\b' ) goto PUTCHAR_BS	
		
		cmp	POS_CURSOR , #21
		bgt	PUTCHAR_ERROR_CD	; Cursor FORA dos Limites do Visor para Texto
		cmp	POS_CURSOR, #0	
		blt	PUTCHAR_ERROR_CD
		
		mov	POS_CURSOR, R0	
		mov	R5, VISOR(R0)		; Escreve na tela
		clr	flag_piscar_cursor
						
		cmp 	POS_CURSOR, #21
		beq 	FIM_PUTCHAR					;return 0
		
		INC_CURSOR:
				inc 	POS_CURSOR			; POS_CURSOR++
				jmp 	FIM_PUTCHAR			; return 0
		
		PUTCHAR_ERROR_EI:
				mov 	#1 , R0
				rts 	R7				; return 1
				
		PUTCHAR_ERROR_CD:
				mov 	#2 , R0
				rts 	R7				; return 2

		PUTCHAR_CR:
				clr 	POS_CURSOR
				jmp 	FIM_PUTCHAR			; return 0
		PUTCHAR_BS:
				mov	POS_CURSOR, R0			; 
				clr 	VISOR(R0)			; VISOR[ POS_CURSOR ] = 0
				clr	backup_char
				tst 	POS_CURSOR
				beq 	FIM_PUTCHAR			; return 0

				dec 	POS_CURSOR			; POS_CURSOR --
		FIM_PUTCHAR:
				mov	#0, R0
				rts	R7
;		
;------------------------------------------------------------------------------
; Essa função fornece as informações relativas à situação atual de cada relógio, 
; no que diz respeito à sua visibilidade e se está andando. 
; - Parâmetros de entrada: registrador R5, com o identificador do relógio a ser lido.
;   Esse valor pode ser 0 (zero) ou 1 (um). 
; Outros valores devem ser ignorados. 
; - Parâmetro de saída: registrador R0, com a indicação do estado do relógio (visibilidade e se está parado). 
; No retorno da função, o registrador R0 conterá as informações do estado do relógio em seus bits 0 e bit 1. 
; O bit 0, quando ligado (valor “1”), indica que o relógio está visível;
; O bit 1, quando ligado (valor “1”), indica que o relógio está andando. 
;------------------------------------------------------------------------------
_get_clock_status:
	; Checa se relógio existe
	cmp 	R5, #0
	blt 	RELOGIO_INEXISTENTE		
	cmp 	R5, #1 
	bgt 	RELOGIO_INEXISTENTE		
	
	; Retorno normal ( em caso de relógio existente: R5 == 0 v R5 == 1 )	
	mov 	CLKST(R5), R0
	rts 	R7			; return CLKST[ R5 ]
	
	; Retorno anômalo ( em caso de relógio inexistente: R5 != 0 ^ R5 != 1 )	
	RELOGIO_INEXISTENTE:		
			mov 	#0, R0
			rts	R7
	
;		
;------------------------------------------------------------------------------
; Essa função fornece o valor atual de cada relógio.
; Essa informação é fornecida como um número inteiro de segundos.
; Como cada relógio tem minutos e segundos,
;     o valor fornecido deverá ser o resultado da aplicação da seguinte fórula (60*MIN+SEG). 
; - Parâmetros de entrada: registrador R5, com o identificador do relógio a ser lido.
;   Esse valor pode ser 0 (zero) ou 1 (um). Outros valores devem ser ignorados. 
; - Parâmetro de saída: registrador R0, com o número de segundos atualmente presentes no relógio. 
; No retorno da função, o registrador R0 conterá o número de segundos correspondentes à informação atual no relógio.
; Essa informação corresponde àquela presente no relógio, independentemente de seu estado (visível/invisível ou parado/andando). 
;------------------------------------------------------------------------------
_get_clock_time:
		; Verifica se relógio existe
		cmp 	R5, #0
		blt 	FIM_GETTIME_A
		cmp 	R5, #1
		bgt	FIM_GETTIME_A

		; Salva Registradores
		mov 	R1, -(R6)		; Salva valor de R1
		mov 	R5, -(R6)   		; Salva valor de R5
		
		; Minutos
		asl	R5				;|
		mov 	CLKTM(R5), R1			;|> R1 = CLKTM[ CÓD_CLK ][1]     <=>   R1 = *(CLKTM + CÓD_CLK*2 + 0 )

		jsr 	R7, mintoseg			; R0 = mintoseg( R1 )		 <=>   R0 = 60 * CLKTM[ CÓD_CLK ][1]
		
		; Segundos
		inc	R5				;|
		add 	CLKTM(R5), R0			;| R0 += CLKTM[ CÓD_CLK ][1] 	
		jmp	FIM_GETTIME
		

		FIM_GETTIME_A:
				clr	R0
				rts	R7
		FIM_GETTIME:		
				mov 	(R6)+, R5		; Restaura registrador R5
				mov 	(R6)+, R1		; Restaura registrador R1
				rts	R7
		
;		
;------------------------------------------------------------------------------
; Essa função é usada para indicar ao kernel se o relógio deve “andar” ou “parar”.  
; - Parâmetros de entrada: 
;   - registrador R5, com o identificador do relógio a ser ativado/desativado.
;     Esse valor pode ser 0 (zero) ou 1 (um). Outros valores devem ser ignorados; 
;   - registrador R4, com a indicação do estado a ser colocado o relógio.
;     Esse valor pode ser 0 (zero), caso o relógio deva parar,
;     ou um valor diferente de 0 (zero), caso o relógio deva andar. 
; - Parâmetro de saída: registrador R0, com o código de erro de retorno. 
; A função retorna no registrador R0 um código de erro. 
; - Se não houve erro, o valor em R0 será zero; 
; - Se houve algum erro ou informação inválida de entrada,
;   o valor em R0 será um valor qualquer diferente de zero. 
;------------------------------------------------------------------------------
_turnon_clock:
		; Testar Parâmetros de entrada
		
			
		; Seleção de Ação
		tst 	R4
		beq 	PAUSAR_CLK
		jmp 	REATIVAR_CLK

		
		PAUSAR_CLK:
				and 	#hFD, CLKST(R5)	; Aplica máscara para desligar bit 1 { SA }
				jmp	END_TURNONCLK
		REATIVAR_CLK:
				or 	#2, CLKST(R5)		; Aplica máscara para ligar bit 1 { SA }
	
		END_TURNONCLK:
				mov 	#0, R0
				rts	r7
		
;		
;------------------------------------------------------------------------------
; Essa função é usada para indicar ao kernel que o relógio deve ser zerado.
; Ou seja, minutos e horas armazenado no relógio devem ser zerados. 
; - Parâmetros de entrada: registrador R5, com o identificador do relógio a ser zerado.
;   Esse valor pode ser 0 (zero) ou  1 (um). Outros valores devem ser ignorados; 
; - Parâmetro de saída: registrador R0, com o código de erro de retorno. 
; A função retorna no registrador R0 um código de erro. 
; - Se não houve erro, o valor em R0 será zero; 
; - Se houve algum erro ou informação inválida de entrada,
;          o valor em R0 será um valor qualquer diferente de zero. 
;------------------------------------------------------------------------------
_clr_clock:
		; Zerar Décimos de Segundos
		clr	CLKTM_DS(R5)	
		
		; Zerar Minutos
		mov	R5, R0
		asl	R0			; R0 = 2*R5
		clr 	CLKTM(R0)		; Zera Minutos   <=>   CLKTM[ R5 ][ 0 ] = 0   <=>  *(CLKTM + 2*R5 + 0 )   <=>   *(CLKTM + QTD_LINHAS*CLK_ATUAL + CAMPO_ATUAL )
		
		; Zerar Segundos
		inc 	R0
		clr 	CLKTM(R0)		; Zera Segundos  <=>   CLKTM[ R5 ][ 1 ] = 0   <=>  *(CLKTM + 2*R5 + 1 ) 
		
		
		END_CLR_CLK:
				mov 	#0, R0
				rts	r7


;		
;------------------------------------------------------------------------------
; Tratador de interrupções( Interrupt Service Routine )
; Função invocada a cada interrupção de hardware. Analisa qual ou quais periféricos
; provocou ou provocaram a interrupções e define ação a ser tomada.
; - Parâmetros de entrada: variável INTS, cujo bit zero informa se timer provocou interrupção,
; e o bit um informa se o teclado invocou a interrupção. O o bit ativo signifa que aquele periférico,
; solicitou uma interrupção. Obs.: Pode acontecer de mútiplos periféricos solicitarem a interrupção,
;  no mesmo ciclo.
;   Esse valor pode ser 81h (Timer) ou  82h (Teclado) ou 83h(Timer e Teclado).
 
;------------------------------------------------------------------------------
Isr:		
		and		#h7F, INTE	; Pausa interrupções  
		
		mov		r0,-(r6)	; Salva registradores
		mov		r1,-(r6)
		mov		r2,-(r6)
		mov		r3,-(r6)
		mov		r4,-(r6)
		mov		r5,-(r6)
		
		mov		INTS,r0		; Verifica se é INT do TECLADO
		and		#2,r0
		beq		ISR2
		jsr		R7,ISRtec	; Tratamento da INT do TECLADO
		and		#hFFFD,INTS	; Desliga bit de INT TECLADO		

		ISR2:		
				mov		INTS,r0		; Verifica se é INT do TIMER
				and		#1,r0
				beq		ISR3
				mov		INTE,r0		; Verifica se é INT do TIMER
				and		#1,r0
				beq		ISR3
				jsr		r7,ISRtim	; Tratamento da INT do TIMER
				and		#hFFFE,INTS	; Desliga bit de INT TIMER

		ISR3:
				mov		(r6)+,r5	; Retorna os registradores da pilha
				mov		(r6)+,r4
				mov		(r6)+,r3
				mov		(r6)+,r2
				mov		(r6)+,r1
				mov		(r6)+,r0
				or		#h80, INTE	; Reativa interrupções  
		
		FIM_ISR:
			rti					; Return From Interrupt


; Tratamento das interrupções de teclado
ISRtec:	
		tst		TECST		
		beq		ISRtec_FIM
		
		cmp 		TECDT, #','
		beq		TROCAR_VIS_0
		cmp 		TECDT, #'.'
		beq		TROCAR_VIS_1
		
		cmp 		TECDT, CR
		jmp		SALVA_NO_BUFFER
		cmp 		TECDT, BS
		jmp		SALVA_NO_BUFFER

		cmp		TECDT, #h20
		blt		ISRtec_FIM
		cmp		TECDT, #h7A
		bgt		ISRtec_FIM

		; Se for um caractere permitido salva no buffer
		SALVA_NO_BUFFER:					
			mov	TECDT, BUFFER
		
		ISRtec_FIM:
			clr 	TECST
			clr 	TECDT					
			rts	r7						

		TROCAR_VIS_0:	
				mov 	#0, R0
				jmp	TROCAR_VIS
		TROCAR_VIS_1:
				mov 	#1, R0

		TROCAR_VIS:
				mov	CLKST(R0), R1
				not	R1
				and	#1, R1
			
				and	#hFE, CLKST(R0)
				add	R1, CLKST(R0) 

				jmp	ISRtec_FIM



; Tratamento das interrupções provacadas pelo timer
;
; Descrição: O timer invoca a interrupção a cada 100 ms
;
; Ação: Incrementa os décimos de segundos dos relógios com
; status de ativação ligado.
ISRtim:
		; Controle de alternância do cursor
		inc	flag_piscar_cursor
		cmp	flag_piscar_cursor, #10
		blt	CONTINUA_ISRtim
		clr	flag_piscar_cursor
		
		CONTINUA_ISRtim:

		clr	 clk_atual			; Relógio(clk) atual = 0
		;clr	 flag_redesenho			; flag_redesenho = false
		mov	 #1, flag_redesenho


		ATUALIZA_TEMPO_CLKS:													; do{
			; Checa Status de Ativação do Relógio
			mov 	clk_atual, R5			;|
			jsr	R7, _get_clock_status		;|
			and 	#2 , R0				;|
			bne 	CONTINUA			;| 
			mov	#1, flag_redesenho		;|
			jmp 	SET_PROX_RELOGIO		;|> Checagem

			CONTINUA:
			; Seleção do Relógio
			mov 	clk_atual, R5			
			
			
			; Décimos de Segundos
			inc	CLKTM_DS(R5)			;| 
			cmp 	CLKTM_DS(R5), #10		;|
			blt	SET_PROX_RELOGIO		;|
			clr 	CLKTM_DS(R5)			;|> Atualiza valor dos décimos de segundos do clk	
			
			mov	TRUE, flag_redesenho		; Ativa redesenho
			
			; Segundos			
			asl		R5				; R5 = 2 * Código do Relógio Escolhido( o->clk0 ou 1-> clk1 )
			inc		R5				; R5 ++; Define Campo Atual como Segundos
			
			inc		CLKTM(R5)			;| *(CLKTM + clk_atual * 2 + 1 ) += 1
			cmp 		CLKTM(R5), #60			;|
			bne 		SET_PROX_RELOGIO		;|
			clr 		CLKTM(R5)			;|> Atualiza valor dos segundos do clk 
			 
			; Minutos
			dec		R5				; R5 --; Define Campo Atual como Minutos

			inc		CLKTM(R5)			;| *(CLKTM + clk_atual * 2 + 0 ) += 1	
			cmp 		CLKTM(R5), #60			;|
			bne 		SET_PROX_RELOGIO		;|
			clr 		CLKTM(R5)			;|> Atualiza valor dos minutos do clk
					

			SET_PROX_RELOGIO:
					inc 		clk_atual		; clk_atual++
					cmp		clk_atual, #2
					bne		ATUALIZA_TEMPO_CLkS
					jmp		REDESENHA_CLK									; }while( !( clk_atual >= 2 ) );    <=>    }while( clk_atual < 2 );
			
		; Se necessário redesenha os relógios		
		REDESENHA_CLK:
			tst		flag_redesenho		;| if( flag_redesenho )
			beq		FIM_ISRtim		;|	redesenha_clks()
			jsr		R7, redesenha_clks	;|	
		
		FIM_ISRtim:
			rts 		R7
		
		; Variáveis Locais Da ISRtim
		flag_redesenho:	dw		; Indica se é necessário redesenhar os relógios( Alterações exclusivas nos décimos de segundos não requerem redesenho )
		clk_atual:	dw		; Indicador do relógio selecionado ( o valor é o código do teclado, 0 ou 1 )

;		
;------------------------------------------------------------------------------
; Limpa todos os blocos do visor
; - Parâmetros de entrada: nenhum
; - Parâmetro de saída: nenhum 
;------------------------------------------------------------------------------
limpa_visor:
		mov 	R0 , -(R6)	; Salva R0
		
		
		mov 	#35 , R0
		
		continua_lv:
			clr	VISOR(R0)
			tst	R0
			beq	ret_lv
			
			dec	R0
			jmp	continua_lv

		ret_lv:
			mov	(R6)+ , R0	; Restaura valor original de R0                
			rts	r7

		
;------------------------------------------------------------------------------
; Mutiplica dois números de 16 bits
; - Parâmetros de entrada: 
;				R1 -> Multiplicando
;				R2 -> Multiplicador
; - Parâmetro de saída: 
;				R0 -> Produto
;------------------------------------------------------------------------------
multiplica:
                
			rts		r7

;		
;-----------------------------------------------------------------------------
; Converte valor de tempo em minutos para segundos
; - Parâmetros de entrada: 
;				R1 -> Tempo em Minutos
; - Parâmetro de saída: 
;				R0 -> Tempo em Segundos
;------------------------------------------------------------------------------
mintoseg:
        		clr R0
			
			SOMA_60:
				add 	#60, R0
				sob	 R1, SOMA_60
						        
			rts	R7

;		
;-----------------------------------------------------------------------------
; Redesenha relógios
; - Parâmetros de entrada: nenhum
;				
; - Parâmetro de saída:  nenhum
;
; - Funções dos Registradores na Sub-rotina
;	* R0: Auxiliar
;	* R1: Parâmetros de subrotinas de divisão
;	* R2: Parâmetros de subrotinas de multiplicação e divisão
;	* R3: Posição No Display Para Escrita 
;	* R4: Código do Relógio Atual	
;------------------------------------------------------------------------------
redesenha_clks:
        	; Inicialização
		clr	clk_atual_2	; Clock_Atual = 0
		
		mov	R0, -(R6)	;|		
		mov	R1, -(R6)	;|		
		mov	R2, -(R6)	;|		
		mov	R3, -(R6)	;|		
		mov	R4, -(R6)	;|
		mov	R5, -(R6)	;|> Arquivamento de registradores
		
		DESENHA_CLKS:	
				LOOP_DESENHO:
					; Set Relógio Atual
					mov	clk_atual_2, R4

					; Checagem de Status de Visibilidade do Relógio
					mov	CLKST(R4), R0
					and	#1, R0
					beq	LMP_DISPLAY_CLK
					
					; Desenhar sinal de  Dois pontos
					asl	R4			; R4 *= 2
					mov 	pos_display(R4), R3
					add	#2, R3 
					mov	#':', VISOR(R3)		; Desenha Dois pontos   <=>  VISOR[R3] = ':'

				
					; Tempo - Primeiro Segundos, depois Minutos
					UNIDADES:
						mov	#1, R5
						inc 	R3			
						jmp	UNIDADES_DEZENAS
					DEZENAS:
						mov	#0, R5
						mov 	pos_display(R4), R3

					UNIDADES_DEZENAS:
						mov	clk_atual_2, R0		;|
						asl	R0			;|
						add	R5, R0			;|
						mov 	CLKTM(R0), R1		;|> R1 = CLKTM[ clk_atual_2 ][R5]
		
						jsr	R7, divd_int_10		;|
						add	#48, R2 		;|
						mov	R2, VISOR(R3)		;|> Dezenas
				
						sub	#48, R2			;|
						jsr	R7, multp_int_10	;|
						sub	R2, R1			;|
										;|		
						inc 	R3			;|
						add	#48, R1 		;|
						mov	R1, VISOR(R3)		;|> Unidades

						tst	R5			;|
						bne	DEZENAS			;|if( R5 ) goto DEZENAS;
					
					INC_CLK_ATUAL:
						inc	clk_atual_2
						cmp	clk_atual_2, #2
						bne     LOOP_DESENHO

		
			FIM_redesenha_clks:
				mov	(R6)+, R5		;|		
				mov	(R6)+, R4		;|		
				mov	(R6)+, R3		;|		
				mov	(R6)+, R2		;|		
				mov	(R6)+, R1		;|		
				mov	(R6)+, R0		;|> Restauração de registradores
				
				rts	r7
	
			
			LMP_DISPLAY_CLK:
				asl	R4
				mov 	pos_display(R4), R3
				add	#5, R3
		
				DRAW_SPACES_CLK:	
					dec	R3
					mov 	#' ',VISOR(R3) 
					cmp     R3, pos_display(R4)
					bne	DRAW_SPACES_CLK
				jmp INC_CLK_ATUAL			
		
		; Variáveis Locais
		clk_atual_2:	dw		; Indicador do clock atual
		pos_display:	daw	24,31	; Posição no display do início dos relógios 0 e 1 respectivamente
;		
;-----------------------------------------------------------------------------
; Divisão inteira por 10
; - Parâmetros de entrada: 
;				R1 -> Valor a ser dividido
;				
; - Parâmetro de saída:  
;				R2 -> Divisão
;	
;------------------------------------------------------------------------------
divd_int_10:
		clr 	cont
		mov 	R1, save_divd_10

		LOOP_DIVD_10:
			sub	#10, R1
			tst 	R1
			bmi	FIM_DIVD_10

			inc 	cont		

			tst 	R1
			beq	FIM_DIVD_10

			jmp LOOP_DIVD_10
		
		FIM_DIVD_10:
			mov 	save_divd_10, R1
			mov 	cont, R2
			rts	R7
		
		cont:		dw	
		save_divd_10:	dw

;		
;-----------------------------------------------------------------------------
; Multiplicação inteira por 10
; - Parâmetros de entrada: 
;				R2 -> Valor a ser multiplicado por 10
;				
; - Parâmetro de saída:  
;				R2 -> Produto
;	
;------------------------------------------------------------------------------
multp_int_10:
		clr 	prod

		LOOP_MULT_10:
			tst	R2
			beq	FIM_MULT_10
			add	#10, prod
			dec 	R2		
			jmp 	LOOP_MULT_10
		
		FIM_MULT_10:
			mov 	prod, R2
			rts	R7
		
		prod:		dw
	
;-----------------------------------------------------------------------------
; ########## VARIÁVEIS DO KERNEL  ##############  ( Localizadas após funções)
;-----------------------------------------------------------------------------
POS_CURSOR: 	dw 		0			; Posição do cursor
BUFFER:		dw		0			; Buffer Teclado
CR: 		dw		h0D			; Carriage Return Char
BS: 		dw		h08			; BackSpace Char 
FALSE:		dw		0			
TRUE:		dw		1			

flag_piscar_cursor:	dw	#0			;

org _APP
	nop
	nop
	mov	#'M', R5
	jsr	R7, _putchar
	mov	#'a', R5
	jsr	R7, _putchar
	mov	#1, R4
	mov	#0, R5
	jsr	R7, _turnon_clock
	LOOP:
		nop
		nop
		jmp	LOOP
